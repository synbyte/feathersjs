import { TObject, TInteger, TOptional, TSchema, TIntersect, ObjectOptions } from '@sinclair/typebox';
import { Validator, DataValidatorMap, Ajv } from '@feathersjs/schema';
export * from '@sinclair/typebox';
export * from './default-schemas';
export type TDataSchemaMap = {
    create: TObject;
    update?: TObject;
    patch?: TObject;
};
/**
 * Returns a compiled validation function for a TypeBox object and AJV validator instance.
 *
 * @param schema The JSON schema definition
 * @param validator The AJV validation instance
 * @returns A compiled validation function
 */
export declare const getValidator: <T = any, R = T>(schema: TObject, validator: Ajv) => Validator<T, R>;
/**
 * Returns compiled validation functions to validate data for the `create`, `update` and `patch`
 * service methods. If not passed explicitly, the `update` validator will be the same as the `create`
 * and `patch` will be the `create` validator with no required fields.
 *
 * @param def Either general TypeBox object definition or a mapping of `create`, `update` and `patch`
 * to their respective type object
 * @param validator The Ajv instance to use as the validator
 * @returns A map of validator functions
 */
export declare const getDataValidator: (def: TObject | TDataSchemaMap, validator: Ajv) => DataValidatorMap;
/**
 * A TypeBox utility that converts an array of provided strings into a string enum.
 * @param allowedValues array of strings for the enum
 * @returns TypeBox.Type
 */
export declare function StringEnum<T extends string[]>(allowedValues: [...T]): import("@sinclair/typebox").TUnsafe<T[number]>;
/**
 * Creates the `$sort` Feathers query syntax schema for an object schema
 *
 * @param schema The TypeBox object schema
 * @returns The `$sort` syntax schema
 */
export declare function sortDefinition<T extends TObject>(schema: T): TObject<T["properties"] extends infer T_1 ? { [K in keyof T_1]: TOptional<TInteger>; } : never>;
/**
 * Returns the standard Feathers query syntax for a property schema,
 * including operators like `$gt`, `$lt` etc. for a single property
 *
 * @param def The property definition
 * @param extension Additional properties to add to the property query
 * @returns The Feathers query syntax schema
 */
export declare const queryProperty: <T extends TSchema, X extends {
    [key: string]: TSchema;
}>(def: T, extension?: X) => TOptional<import("@sinclair/typebox").TUnion<[T, import("@sinclair/typebox").TPartial<TIntersect<[TObject<{
    $gt: T;
    $gte: T;
    $lt: T;
    $lte: T;
    $ne: T;
    $in: import("@sinclair/typebox").TArray<T>;
    $nin: import("@sinclair/typebox").TArray<T>;
}>, TObject<X>]>>]>>;
/**
 * Creates a Feathers query syntax schema for the properties defined in `definition`.
 *
 * @param definition The properties to create the Feathers query syntax schema for
 * @param extensions Additional properties to add to a property query
 * @returns The Feathers query syntax schema
 */
export declare const queryProperties: <T extends TObject<import("@sinclair/typebox").TProperties>, X extends T["properties"] extends infer T_1 ? { [K in keyof T_1]?: {
    [key: string]: TSchema;
}; } : never>(definition: T, extensions?: X) => TOptional<TObject<T["properties"] extends infer T_2 ? { [K_1 in keyof T_2]: TOptional<import("@sinclair/typebox").TUnion<[T["properties"][K_1], import("@sinclair/typebox").TPartial<TIntersect<[TObject<{
    $gt: T["properties"][K_1];
    $gte: T["properties"][K_1];
    $lt: T["properties"][K_1];
    $lte: T["properties"][K_1];
    $ne: T["properties"][K_1];
    $in: import("@sinclair/typebox").TArray<T["properties"][K_1]>;
    $nin: import("@sinclair/typebox").TArray<T["properties"][K_1]>;
}>, TObject<X[K_1]>]>>]>>; } : never>>;
/**
 * Creates a TypeBox schema for the complete Feathers query syntax including `$limit`, $skip`, `$or`
 * and `$sort` and `$select` for the allowed properties.
 *
 * @param type The properties to create the query syntax for
 * @param extensions Additional properties to add to the query syntax
 * @param options Options for the TypeBox object schema
 * @returns A TypeBox object representing the complete Feathers query syntax for the given properties
 */
export declare const querySyntax: <T extends TObject<import("@sinclair/typebox").TProperties> | TIntersect<TObject<import("@sinclair/typebox").TProperties>[]>, X extends T["properties"] extends infer T_1 ? { [K in keyof T_1]?: {
    [key: string]: TSchema;
}; } : never>(type: T, extensions?: X, options?: ObjectOptions) => TIntersect<[import("@sinclair/typebox").TPartial<TObject<{
    $limit: import("@sinclair/typebox").TNumber;
    $skip: import("@sinclair/typebox").TNumber;
    $sort: TObject<T["properties"] extends infer T_2 ? { [K_1 in keyof T_2]: TOptional<TInteger>; } : never>;
    $select: import("@sinclair/typebox").TUnsafe<(keyof T["properties"])[]>;
    $and: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TUnion<[TOptional<TObject<T["properties"] extends infer T_3 ? { [K_2 in keyof T_3]: TOptional<import("@sinclair/typebox").TUnion<[T["properties"][K_2], import("@sinclair/typebox").TPartial<TIntersect<[TObject<{
        $gt: T["properties"][K_2];
        $gte: T["properties"][K_2];
        $lt: T["properties"][K_2];
        $lte: T["properties"][K_2];
        $ne: T["properties"][K_2];
        $in: import("@sinclair/typebox").TArray<T["properties"][K_2]>;
        $nin: import("@sinclair/typebox").TArray<T["properties"][K_2]>;
    }>, TObject<X[K_2]>]>>]>>; } : never>>, TObject<{
        $or: import("@sinclair/typebox").TArray<TOptional<TObject<T["properties"] extends infer T_3 ? { [K_2 in keyof T_3]: TOptional<import("@sinclair/typebox").TUnion<[T["properties"][K_2], import("@sinclair/typebox").TPartial<TIntersect<[TObject<{
            $gt: T["properties"][K_2];
            $gte: T["properties"][K_2];
            $lt: T["properties"][K_2];
            $lte: T["properties"][K_2];
            $ne: T["properties"][K_2];
            $in: import("@sinclair/typebox").TArray<T["properties"][K_2]>;
            $nin: import("@sinclair/typebox").TArray<T["properties"][K_2]>;
        }>, TObject<X[K_2]>]>>]>>; } : never>>>;
    }>]>>;
    $or: import("@sinclair/typebox").TArray<TOptional<TObject<T["properties"] extends infer T_3 ? { [K_2 in keyof T_3]: TOptional<import("@sinclair/typebox").TUnion<[T["properties"][K_2], import("@sinclair/typebox").TPartial<TIntersect<[TObject<{
        $gt: T["properties"][K_2];
        $gte: T["properties"][K_2];
        $lt: T["properties"][K_2];
        $lte: T["properties"][K_2];
        $ne: T["properties"][K_2];
        $in: import("@sinclair/typebox").TArray<T["properties"][K_2]>;
        $nin: import("@sinclair/typebox").TArray<T["properties"][K_2]>;
    }>, TObject<X[K_2]>]>>]>>; } : never>>>;
}>>, TOptional<TObject<T["properties"] extends infer T_4 ? { [K_2 in keyof T_4]: TOptional<import("@sinclair/typebox").TUnion<[T["properties"][K_2], import("@sinclair/typebox").TPartial<TIntersect<[TObject<{
    $gt: T["properties"][K_2];
    $gte: T["properties"][K_2];
    $lt: T["properties"][K_2];
    $lte: T["properties"][K_2];
    $ne: T["properties"][K_2];
    $in: import("@sinclair/typebox").TArray<T["properties"][K_2]>;
    $nin: import("@sinclair/typebox").TArray<T["properties"][K_2]>;
}>, TObject<X[K_2]>]>>]>>; } : never>>]>;
export declare const ObjectIdSchema: () => import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TString<string>, TObject<{}>]>;
